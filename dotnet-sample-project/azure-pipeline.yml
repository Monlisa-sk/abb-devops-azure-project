# Test Pipeline
trigger:
  branches:
    include:
      - main
      - feature/*

pool:
  name: AzureVM

variables:
  # CI vars
  SRC_DIR: 'dotnet-sample-project'
  dockerRegistryServiceConnection: 'devops-service-connection'
  imageRepository: 'dotnet-sample-project'
  tag: '$(Build.SourceBranchName)-$(Build.BuildId)'
  # CD vars
  azureSubscription: 'ARM-Service-Connection'
  aksResourceGroup: 'abb-devops'
  aksName: 'abb-aks-cluster'
  acrName: 'devopscontainerreg'
  namespace: 'dev'
  releaseName: 'myapp'
  helmChartPath: '$(Build.SourcesDirectory)/dotnet-sample-project/helmchart'
  imageRepositoryCD: 'devopscontainerreg.azurecr.io/dotnet-sample-project'
  imageTag: 'ci-pipeline-45'

stages:
- stage: BuildAndTest
  displayName: 'Build & Test'
  jobs:
    - job: build_and_test
      displayName: 'Build and Test'
      steps:
        - task: UseDotNet@2
          inputs:
            packageType: 'sdk'
            version: '9.0.x'

        - script: dotnet restore '$(SRC_DIR)/source'
          displayName: 'Restore NuGet packages'

        - script: dotnet build '$(SRC_DIR)/source' --configuration Release --no-restore
          displayName: 'Build solution'

        - script: |
            echo "Discovering test projects in $(SRC_DIR)..."
            set -e
            TEST_PROJECTS=$(find "$(SRC_DIR)/tests" -type f -name "*Tests.csproj" -o -name "*.Tests.csproj" || true)
            if [ -z "$TEST_PROJECTS" ]; then
              echo "No test projects found."
              exit 0
            fi
            for proj in $TEST_PROJECTS; do
              echo "Running tests for $proj"
              dotnet test "$proj" --configuration Release --no-build --collect:"XPlat Code Coverage"  --logger trx
              echo "Completed tests for $proj"
            done
          displayName: 'Run all tests with coverage and logs'

- stage: CodeAnalysis
  displayName: 'SonarQube Build Scan'
  jobs:
  - job: sonarqube
    displayName: SonarQube
    continueOnError: true
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '9.0.x'
    - task: SonarQubePrepare@7
      inputs:
        SonarQube: 'sonarqube-project'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: 'sonarqube-project'
        cliProjectName: 'dotnet-sample-project'
        cliProjectVersion: '$(Build.BuildNumber)'
        extraProperties: |
          sonar.sources=$(SRC_DIR)/source
          sonar.cs.opencover.reportsPaths=$(Build.SourcesDirectory)/$(SRC_DIR)/**/coverage.opencover.xml
          sonar.exclusions=**/*.md

    - script: dotnet build '$(SRC_DIR)/source' 
      displayName: 'Build for analysis'

    - task: SonarQubeAnalyze@7

    - task: SonarQubePublish@7
      inputs:
        pollingTimeoutSec: '300'

- stage: DockerBuild
  displayName: 'Docker Build'
  jobs:
  - job: docker_build
    displayName: 'Build image'
    steps:
    - task: Docker@2
      displayName: 'Build image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'build'
        Dockerfile: 'dotnet-sample-project/Dockerfile'
        tags: '$(tag)'

- stage: Push
  displayName: 'Push image to ACR'
  jobs:
  - job: docker_push
    displayName: 'Push image'
    steps:
    - task: Docker@2
      displayName: 'Push image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'push'
        tags: '$(tag)'

- stage: CD
  displayName: Deploy to AKS
  jobs:
  - job: Deploy
    displayName: Helm deploy 
    steps:
    - task: HelmInstaller@1
      displayName: Install Helm
      inputs:
        helmVersionToInstall: 'latest'
    - task: Kubernetes@1
      displayName: Connect to AKS Cluster
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: 'AKS-Conn'
        command: 'login'

    - script: |
        set -euo pipefail
        echo "Chart path: $(helmChartPath)"
        ls -la "$(helmChartPath)"
        helm upgrade --install myapp-dev "$(helmChartPath)" \
          --namespace dev --create-namespace \
          --set image.repository=$(imageRepositoryCD) \
          --set image.tag=$(imageTag) \
          --atomic --wait --timeout 5m
      displayName: Helm upgrade --install

      # quick always-on view
    - task: Kubernetes@1
      displayName: pods (quick view)
      inputs:
       connectionType: 'Kubernetes Service Connection'
       kubernetesServiceEndpoint: 'AKS-Conn'
       namespace: '$(namespace)'
       command: 'get'
       arguments: 'pods -o wide'

      # runs only if Helm failed)
    - script: |
        set -euo pipefail
        ns="$(namespace)"
        rel="$(releaseName)"

        echo "== rollout status (by label app.kubernetes.io/instance) =="
         # This avoids hardcoding the deployment name:
        P=$(kubectl get pods -n "$ns" -l app.kubernetes.io/instance="$rel" --no-headers 2>/dev/null | awk '$2 !~ /^([0-9]+)\/\1$/ {print $1; exit}')

         echo "== pods =="
        kubectl get pods -n "$ns" -o wide || true

        echo "== first non-Ready pod: describe + logs =="
          # Pick the first pod whose READY column isn't N/N 
        P=$(kubectl get pods -n "$ns" -l app.kubernetes.io/instance="$rel" --no-headers 2>/dev/null | awk '$2 !~ /^([0-9]+)\/\1$/ {print $1; exit}')
        if [ -n "${P:-}" ]; then
          echo "--- describe $P ---"
          kubectl describe pod -n "$ns" "$P" || true
          echo "--- logs $P (last 200 lines) ---"
          kubectl logs -n "$ns" "$P" --tail=200 --prefix || true
        else
          echo "All pods are Ready for release '$rel' in namespace '$ns'."
        fi
      displayName: quick triage (on failure)
      condition: failed()